@kernel void insVelocityRhsWeakHex3D(const dlong Nelements,
                                     const dfloat scale,
                                     @restrict const dfloat*  vgeo,
                                     @restrict const dfloat*  D,
                                     const dlong offset,
                                     @restrict const dfloat*  MUE,
                                     @restrict const dfloat*  DIV,
                                     @restrict const dfloat*  P,
                                     @restrict dfloat*  RHS)
{
  for(dlong e = 0; e < Nelements; ++e; @outer(0)) {
    @shared dfloat s_D[p_Nq][p_Nq];

    @shared dfloat s_MUEDIV[p_Nq][p_Nq][p_Nq];
    @shared dfloat s_P[p_Nq][p_Nq][p_Nq];

    for(int k = 0; k < p_Nq; ++k; @inner(2)) {
      for(int j = 0; j < p_Nq; ++j; @inner(1)) {
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
          if (k==0) {
            const dlong id = i + j * p_Nq;
            s_D[j][i] = D[id];
          }

          const dlong id = e * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          s_MUEDIV[k][j][i] = scale*MUE[id]*DIV[id]; 
          s_P[k][j][i] = P[id]; 
        }
      }
    }

    @barrier("local");

    for(int k = 0; k < p_Nq; ++k; @inner(2)) {
      for(int j = 0; j < p_Nq; ++j; @inner(1)) {
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong gid = e * p_Np * p_Nvgeo + k * p_Nq * p_Nq + j * p_Nq + i;
          const dfloat drdx = vgeo[gid + p_RXID * p_Np];
          const dfloat drdy = vgeo[gid + p_RYID * p_Np];
          const dfloat drdz = vgeo[gid + p_RZID * p_Np];
          const dfloat dsdx = vgeo[gid + p_SXID * p_Np];
          const dfloat dsdy = vgeo[gid + p_SYID * p_Np];
          const dfloat dsdz = vgeo[gid + p_SZID * p_Np];
          const dfloat dtdx = vgeo[gid + p_TXID * p_Np];
          const dfloat dtdy = vgeo[gid + p_TYID * p_Np];
          const dfloat dtdz = vgeo[gid + p_TZID * p_Np];
          const dfloat JW   = vgeo[gid + p_JWID * p_Np];

          // compute 'r' and 's' derivatives of (q_m) at node n
          dfloat dpdr  = 0.f, dpds  = 0.f, dpdt  = 0.f;

#pragma unroll p_Nq
          for(int n = 0; n < p_Nq; ++n) {
            const dfloat Dr = s_D[i][n];
            const dfloat Ds = s_D[j][n];
            const dfloat Dt = s_D[k][n];

            dpdr += Dr * JW*s_P[k][j][n];
            dpds += Ds * JW*s_P[k][n][i];
            dpdt += Dt * JW*s_P[n][j][i];
          }

          const dlong id = e * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          RHS[id + 0 * offset] = -(drdx * dpdr + dsdx * dpds + dtdx * dpdt);
          RHS[id + 1 * offset] = -(drdy * dpdr + dsdy * dpds + dtdy * dpdt);
          RHS[id + 2 * offset] = -(drdz * dpdr + dsdz * dpds + dtdz * dpdt);
        }
      }
    }
  }
}
