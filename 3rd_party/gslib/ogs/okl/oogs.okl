@kernel void packBuf_float(const dlong Nscatter,
                           const   int Nentries,
                           @restrict const  dlong *  scatterStarts,
                           @restrict const  dlong *  scatterIds,
                           @restrict const  float *  q,
                           @restrict dhalf *  scatterq){

  for(dlong s=0;s<Nscatter*Nentries;++s;@tile(256,@outer,@inner)){

    const float qs = q[s];

    const dlong sid = s%Nscatter;
    const int k = s/Nscatter;
    const dlong start = scatterStarts[sid];
    const dlong end = scatterStarts[sid+1];
    
    for(dlong n=start;n<end;++n){
      const dlong id = scatterIds[n];
      dhalf half_qs;
      {
          unsigned int x, u, shift, exponent, mantissa, sign, rem;
          memcpy(&x, &qs, sizeof(qs));
          
          u = (x & static_cast<unsigned int>(0x7fffffff));
          sign = ((x >> 16) & static_cast<unsigned int>(0x8000));
          exponent = u >> 23;
          mantissa = (u & static_cast<unsigned int>(0x7fffff));
          shift = static_cast<unsigned int>(0x7e) - exponent;
          mantissa |= static_cast<unsigned int>(0x800000);
          rem = mantissa << (32 - shift);
          half_qs = static_cast<unsigned short>(sign | (mantissa >> shift));
          if (rem > static_cast<unsigned int>(0x80000000) || 
            rem == static_cast<unsigned int>(0x80000000) && (half_qs & 0x1))
            half_qs++;
      }
      scatterq[id*Nentries+k] = half_qs;
    }
  }
}

@kernel void packBuf_double(const dlong Nscatter,
                            const   int Nentries,
                            @restrict const  dlong *  scatterStarts,
                            @restrict const  dlong *  scatterIds,
                            @restrict const  double *  q,
                            @restrict double *  scatterq){

  for(dlong s=0;s<Nscatter*Nentries;++s;@tile(256,@outer,@inner)){

    const double qs = q[s];
    
    const dlong sid = s%Nscatter;
    const int k = s/Nscatter;
    const dlong start = scatterStarts[sid];
    const dlong end = scatterStarts[sid+1];
    
    for(dlong n=start;n<end;++n){
      const dlong id = scatterIds[n];
      scatterq[id*Nentries+k] = qs;
    }
  }
}

@kernel void unpackBuf_floatAdd(const dlong Ngather,
                                const  int      Nentries,
		                @restrict const  dlong *  gatherStarts,
		                @restrict const  dlong *  gatherIds,
		                @restrict const  dhalf *  q,
		                @restrict float *  gatherq){

  for(dlong g=0;g<Ngather*Nentries;++g;@tile(256,@outer,@inner)){

    const dlong gid = g%Ngather;
    const int k = g/Ngather;
    const dlong start = gatherStarts[gid];
    const dlong end = gatherStarts[gid+1];
     
    float gq = 0.f;
    for(dlong n=start;n<end;++n){
    	const dlong id = gatherIds[n];
      float cast_q = 0.0;
      dhalf half_q = q[id*Nentries+k];
      {
        unsigned int sign = ((half_q >> 15) & 1);
        unsigned int exponent = ((half_q >> 10) & 0x1f);
        unsigned int mantissa = ((half_q & 0x3ff) << 13);
        exponent += static_cast<unsigned int>(0x70);
        unsigned int u = ((sign << 31) | (exponent << 23) | mantissa);
        memcpy(&cast_q, &u, sizeof(u));
      }
    	gq += cast_q;
    }

    //contiguously packed
    gatherq[g] += gq;
  }
}

@kernel void unpackBuf_doubleAdd(const dlong Ngather,
                                 const  int      Nentries,
                                 @restrict const  dlong *  gatherStarts,
                                 @restrict const  dlong *  gatherIds,
                                 @restrict const  double *  q,
                                 @restrict double *  gatherq){
                          
  for(dlong g=0;g<Ngather*Nentries;++g;@tile(256,@outer,@inner)){

    const dlong gid = g%Ngather;
    const int k = g/Ngather;
    const dlong start = gatherStarts[gid];
    const dlong end = gatherStarts[gid+1];
     
    double gq = 0.f;
    for(dlong n=start;n<end;++n){
      const dlong id = gatherIds[n];
      gq += q[id*Nentries+k];
    }

    //contiguously packed
    gatherq[g] += gq;
  }
}

@kernel void unpackBuf_doubleMin(const dlong Ngather,
                                 const  int      Nentries,
                                 @restrict const  dlong *  gatherStarts,
                                 @restrict const  dlong *  gatherIds,
                                 @restrict const  double *  q,
                                 @restrict double *  gatherq){
                          
  for(dlong g=0;g<Ngather*Nentries;++g;@tile(256,@outer,@inner)){

    const dlong gid = g%Ngather;
    const int k = g/Ngather;
    const dlong start = gatherStarts[gid];
    const dlong end = gatherStarts[gid+1];
     
    const dlong startId = gatherIds[start];
    double gq = q[startId*Nentries+k];
    for(dlong n=start;n<end;++n){
      const dlong id = gatherIds[n];
      gq = (q[id*Nentries+k] < gq) ? q[id*Nentries+k] : gq;
    }

    //contiguously packed
    gatherq[g] = gq;
  }
}

@kernel void unpackBuf_doubleMax(const dlong Ngather,
                                 const  int      Nentries,
                                 @restrict const  dlong *  gatherStarts,
                                 @restrict const  dlong *  gatherIds,
                                 @restrict const  double *  q,
                                 @restrict double *  gatherq){
                          
  for(dlong g=0;g<Ngather*Nentries;++g;@tile(256,@outer,@inner)){

    const dlong gid = g%Ngather;
    const int k = g/Ngather;
    const dlong start = gatherStarts[gid];
    const dlong end = gatherStarts[gid+1];
     
    const dlong startId = gatherIds[start];
    double gq = q[startId*Nentries+k];
    for(dlong n=start;n<end;++n){
      const dlong id = gatherIds[n];
      gq = (q[id*Nentries+k] > gq) ? q[id*Nentries+k] : gq;
    }

    //contiguously packed
    gatherq[g] = gq;
  }
}
